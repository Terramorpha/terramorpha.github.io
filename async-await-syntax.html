<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Implementing ~async~-~await~ syntax using delimited continuations</title>
<meta name="author" content="Justin Veilleux" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  pre.src-C\+\+:before { content: 'C++'; }
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'JavaScript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="Agda.css" />
<style>.org-latex-block { margin: auto; } </style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Implementing <code>async</code>-<code>await</code> syntax using delimited continuations</h1>
<p>
The idea of a monad abstracts over a bunch of different effects:
</p>

<ol class="org-ol">
<li>Within the list monad, you have something like <code class="src src-haskell"><span style="color: #8f0075;">choose</span> <span style="color: #3548cf;">::</span> [a] <span style="color: #3548cf;">-&gt;</span> a</code>, a nondeterministic choice operator.</li>
<li>Within the maybe monad, you have something like <code class="src src-haskell"><span style="color: #8f0075;">unwrap</span> <span style="color: #3548cf;">::</span> <span style="color: #531ab6; font-weight: bold;">Maybe</span> a <span style="color: #3548cf;">-&gt;</span> a</code> that asserts that there is a value and gives it to you.</li>
<li>Within the state monad, you have something like <code class="src src-haskell"><span style="color: #8f0075;">act</span> <span style="color: #3548cf;">::</span> <span style="color: #531ab6; font-weight: bold;">State</span> s x <span style="color: #3548cf;">-&gt;</span> x</code>, an operator that lets you mutate global state.</li>
<li>Within the continuation monad, you have access to weird control operators
that let you emulate java-style exceptions.</li>
</ol>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>The definition of the monad typeclass.</label><pre class="src src-haskell"><code><span style="color: #595959; font-style: italic;">-- </span><span style="color: #595959; font-style: italic;">The definition of the monad typeclass
</span><span style="color: #005e8b; font-weight: bold;">class</span> <span style="color: #531ab6; font-weight: bold;">Monad</span> f <span style="color: #005e8b; font-weight: bold;">where</span>
  return <span style="color: #3548cf;">::</span> x <span style="color: #3548cf;">-&gt;</span> f x
  bind <span style="color: #3548cf;">::</span> f x <span style="color: #3548cf;">-&gt;</span> (x <span style="color: #3548cf;">-&gt;</span> f y) <span style="color: #3548cf;">-&gt;</span> f y
</code></pre>
</div>

<p>
In every language that supports higher order functions, one could theoretically
achieve the same amount of purity and side effect-lessness by writing code in
callback passing style everywhere, but only in Haskell do you <b>have</b> to. For that
reason, Haskell has do notation which lets programmers write equivalent code,
but in a more direct style.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 2: </span>The ever increasing nesting that is characteristic of callback use is completely eliminated when using do-notation.</label><pre class="src src-haskell"><code><span style="color: #8f0075;">jsonRequest</span> <span style="color: #3548cf;">::</span> <span style="color: #531ab6; font-weight: bold;">String</span> <span style="color: #3548cf;">-&gt;</span> <span style="color: #531ab6; font-weight: bold;">Promise</span> <span style="color: #531ab6; font-weight: bold;">Json</span>
<span style="color: #8f0075;">jsonRequest</span> url <span style="color: #3548cf;">=</span>
  fetch url <span style="color: #3548cf;">&gt;&gt;=</span> <span style="color: #3548cf;">\</span>response <span style="color: #3548cf;">-&gt;</span>
    parseJson response <span style="color: #3548cf;">&gt;&gt;=</span> <span style="color: #3548cf;">\</span>json <span style="color: #3548cf;">-&gt;</span>
      pure json
                               

<span style="color: #8f0075;">jsonRequest'</span> <span style="color: #3548cf;">::</span> <span style="color: #531ab6; font-weight: bold;">String</span> <span style="color: #3548cf;">-&gt;</span> <span style="color: #531ab6; font-weight: bold;">Promise</span> <span style="color: #531ab6; font-weight: bold;">Json</span>
<span style="color: #8f0075;">jsonRequest'</span> url <span style="color: #3548cf;">=</span> <span style="color: #005e8b; font-weight: bold;">do</span>
  response <span style="color: #3548cf;">&lt;-</span> fetch url
  json <span style="color: #3548cf;">&lt;-</span> parseJson response
  pure json
</code></pre>
</div>

<p>
It would be nice to have do notation in impure languages. It would make writing
purely functional code less daunting and extend the reach of pure function&rsquo;s
virtues even further.
</p>

<p>
Actually, in some (rare tbh) circumstances, it is totally possible, but before
we see why, let&rsquo;s look at one less well-known monad: the continuation monad.
Without going in too deep, the continuation monad is monad within which one has
access to &ldquo;control operations&rdquo; like throwing exceptions, returning early, doing
(controlled) goto. In other words, operations that require non local &ndash; weird &ndash;
control flow.
</p>

<p>
While Haskell can &ldquo;emulate&rdquo; these weird control flow operations through the
continuation monad(which are just callbacks) and do notation, it is actually
possible to implement do notation using one of those weird control flow
primitives: delimited continuation. Before, however, I go about explaining the
(quite unintuitive) concept of a delimited continuation, we need to make a brief
detour in the more pragmatic land of Javascript promises.
</p>
<div id="outline-container-orged68943" class="outline-2">
<h2 id="orged68943"><span class="section-number-2">1.</span> <code>async</code> and <code>await</code> in Javascript</h2>
<div class="outline-text-2" id="text-1">
<p>
One very popular monad (it is very much used outside the functional programming
community) is the concept of promise. A promise is a value that you do not yet
have, but that you want to manipulate. For instance, the Javascript
<code class="src src-js">fetch</code> function returns promises which you manipulate through the
<code class="src src-js">.then</code> method:
</p>

<div class="org-src-container">
<pre class="src src-js"><code><span style="color: #005e8b; font-weight: bold;">const</span> <span style="color: #3548cf;">resp_promise</span> = fetch(<span style="color: #a0132f;">"http://example.org/"</span>);
resp_promise.then(resp =&gt; {
    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Something ...
</span>    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">...
</span>})
</code></pre>
</div>

<p>
As any web developper knows, using <code class="src src-js">.then</code> for managing sequential
promises make for very ugly code. This is the same &ldquo;callback hell&rdquo; we had in the
earlier haskell snippet.
</p>

<div class="org-src-container">
<pre class="src src-js"><code><span style="color: #005e8b; font-weight: bold;">const</span> <span style="color: #3548cf;">resp_promise</span> = fetch(<span style="color: #a0132f;">"http://example.org/"</span>);
resp_promise.then(resp =&gt; {
    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Something ...
</span>    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">...
</span>    something.then(value =&gt; {
        <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">...
</span>        something_else.then(x =&gt; {
            <span style="color: #595959; font-style: italic;">//</span><span style="color: #595959; font-style: italic;">...
</span>        })
    })
})
</code></pre>
</div>

<p>
Javascript&rsquo;s solution to this problem is <code>async</code> and <code>await</code>. Using <code>await</code> on a
promise will make the program look as if it is waiting for the result and <code>async</code>
marks a function in which you would like to use <code>await</code>. It turns out that this
piece of syntactic sugar is the same as the more general <code>do</code> notation in Haskell.
just replace a <code>do</code> block by an <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">async</span></code> function and each <code class="src src-haskell"><span style="color: #3548cf;">&lt;-</span></code> by
the <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">await</span></code> keyword! Operationnally, each of those constructs take the
continuation of the <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">await</span></code> / <code class="src src-haskell"><span style="color: #3548cf;">&lt;-</span></code> point and pass it to the
<code class="src src-js">.then</code> / <code class="src src-haskell"><span style="color: #3548cf;">&gt;&gt;=</span></code>!
</p>
</div>
</div>
<div id="outline-container-org1eff3a4" class="outline-2">
<h2 id="org1eff3a4"><span class="section-number-2">2.</span> The concept of a continuation</h2>
<div class="outline-text-2" id="text-2">
<p>
Before we dive into the technical details of implementing <code>async</code> / <code>await</code> syntax,
let me first explain what continuations are. The concept of a continuation
captures the idea of &ldquo;the rest of the program&rdquo; from a certain point. Let&rsquo;s say
an interpreter has just finished calculating the <code class="src src-js">b*b - 4 * a * c</code> sub
expression of the quadratic formula:
</p>

<div class="org-src-container">
<pre class="src src-js"><code>(-b + sqrt(b*b - 4 * a * c))/(2*a)
</code></pre>
</div>

<p>
The state of the interpreter holds the computed value (the results of evaluating
<code class="src src-js">b*b - 4 * a * c</code> ) and what to do with it after. That information is the
continuation. Thinking about continuations is useful for writing compilers, but
it is also useful in other contexts. For instance, there is a certain program
transformation called Continuation-Passing-Style conversion.
</p>

<p>
Here is how we compute the transformation:
</p>

<ol class="org-ol">
<li>For every function in the program, we add a parameter <code class="src src-js">cont</code>, the &ldquo;continuation&rdquo;. At
runtime, this parameter will contain the callback the program must call with
its result.</li>
<li>Within every function, we replace <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">return</span> something</code> with
<code class="src src-js">cont(something)</code>.</li>
<li>At each function call, we must add the continuation callback which would
contain everything coming after the function call.</li>
</ol>

<p>
As the simplest example, let&rsquo;s cps convert the identity function:
</p>

<div class="org-src-container">
<pre class="src src-js"><code><span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">identity</span>(<span style="color: #3548cf;">x</span>) {
    <span style="color: #005e8b; font-weight: bold;">return</span> x;
}

<span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">identity_cps</span>(<span style="color: #3548cf;">x</span>, <span style="color: #3548cf;">cont</span>) {
    cont(x);
}
</code></pre>
</div>

<p>
When a function doesn&rsquo;t call other functions, cps conversion is just a matter of
replacing every return statement by a call to the continuation.
</p>

<p>
Let&rsquo;s move on to a harder example. Let&rsquo;s CPS-convert the <code class="src src-js">fib</code> function.
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 3: </span>A function computing the nth term of the fibonacci sequence, written in direct style.</label><pre class="src src-js"><code><span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">fib</span>(<span style="color: #3548cf;">n</span>) {
    <span style="color: #005e8b; font-weight: bold;">if</span> (n &lt;= 1) {
        <span style="color: #005e8b; font-weight: bold;">return</span> n
    } <span style="color: #005e8b; font-weight: bold;">else</span> {
        <span style="color: #005e8b; font-weight: bold;">return</span> fib(n - 1) + fib(n-2);
    }
}

console.log(fib(5))
</code></pre>
</div>

<pre class="example">
5
</pre>

<p>
It becomes the following:
</p>
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 4: </span>The same function, in CPS style.</label><pre class="src src-js"><code><span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">fib_cps</span>(<span style="color: #3548cf;">n</span>, <span style="color: #3548cf;">cont</span>) {
    <span style="color: #005e8b; font-weight: bold;">if</span> (n &lt;= 1) {
        cont(n);
    } <span style="color: #005e8b; font-weight: bold;">else</span> {
        fib_cps(n - 1, r1 =&gt; {
            fib_cps(n - 2, r2 =&gt; {
                cont(r1 + r2);
            })
        })
    }
}

fib_cps(5, res =&gt; {
    console.log(res);
})
</code></pre>
</div>

<pre class="example">
5
</pre>

<p>
For those of you familiar with Javascript asynchronous programming, its as if we
had made every single function in the program async. However, instead of calling
a method <code class="src src-js">.then</code> here, we pass the callback directly to the function.
</p>
</div>
<div id="outline-container-orgfb9602d" class="outline-3">
<h3 id="orgfb9602d"><span class="section-number-3">2.1.</span> Representation in memory</h3>
<div class="outline-text-3" id="text-2-1">
<p>
An interesting consequence of such a transformation will become apparent once we
imagine what the <code class="src src-js">cont</code> object looks like deep in the call stack.
</p>

<p>
Let&rsquo;s look at this very simple (normal) function and what the anonymous function
it returns look like in memory.
</p>

<div class="org-src-container">
<pre class="src src-js"><code><span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">quadratic</span>(<span style="color: #3548cf;">a</span>, <span style="color: #3548cf;">b</span>, <span style="color: #3548cf;">c</span>) {
    <span style="color: #005e8b; font-weight: bold;">return</span> (-b + sqrt(b*b - 4 * a * c)) / (2*a)
}

<span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">quadratic_ab</span>(<span style="color: #3548cf;">a</span>, <span style="color: #3548cf;">b</span>) {
    <span style="color: #005e8b; font-weight: bold;">return</span> <span style="color: #005e8b; font-weight: bold;">function</span>(<span style="color: #3548cf;">c</span>) {
        <span style="color: #005e8b; font-weight: bold;">const</span> <span style="color: #3548cf;">x</span> = quadratic(a, b, c);
        <span style="color: #005e8b; font-weight: bold;">return</span> x;
    };
}


<span style="color: #005e8b; font-weight: bold;">let</span> <span style="color: #3548cf;">quad12</span> = quadratic_ab(1, 2);
</code></pre>
</div>



<div id="org03490c5" class="figure">
<p><img src="./assets/plus-closure-repr.svg" alt="plus-closure-repr.svg" class="org-svg" />
</p>
</div>

<p>
If we have an anonymous functions points in its closure to another anonymous
functions that points to &hellip;, we get something that looks a lot like a call
stack!
</p>


<div id="org10131b4" class="figure">
<p><img src="./assets/closure-stack.svg" alt="closure-stack.svg" class="org-svg" />
</p>
</div>


<p>
Each layer contains local variables and a code pointer and a pointer the the
layer after&hellip; This structure is essentially a linked list heap allocated call
stack!
</p>

<p>
Another neat consequence of this is the fact that if write recursive code, we
get tail call optimization for free! Tail call elimination can be applied by the
compiler on a function call when that call is &ldquo;terminal&rdquo; in a function, i.e.
followed immediately by a return. For example, here is a (normal style)
recursive function that is not tail recursive:
</p>

<div class="org-src-container">
<pre class="src src-js"><code><span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">sum</span>(<span style="color: #3548cf;">xs</span>) {
    <span style="color: #005e8b; font-weight: bold;">if</span> (xs.length == 0) {
        <span style="color: #005e8b; font-weight: bold;">return</span> 0;
    } <span style="color: #005e8b; font-weight: bold;">else</span> {
        <span style="color: #005e8b; font-weight: bold;">return</span> xs[0] + sum(xs.slice(1));
    }
}
</code></pre>
</div>

<p>
Notice that once we have called sum in the recursive branch, we still need to do
work to add the result to <code class="src src-js">xs[0]</code>. If we cps-convert this function, we
notice that each call adds a layer to the heap allocated call stack.
</p>

<div class="org-src-container">
<pre class="src src-js"><code><span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">sum_cps</span>(<span style="color: #3548cf;">xs</span>, <span style="color: #3548cf;">ret</span>) {
    <span style="color: #005e8b; font-weight: bold;">if</span> (xs.length == 0) {
        ret(0);
    } <span style="color: #005e8b; font-weight: bold;">else</span> {
        sum(xs.slice(1), res =&gt; {
            ret(1 + res);
        });
    }
}
</code></pre>
</div>

<p>
However, a different way to write the same function:
</p>

<div class="org-src-container">
<pre class="src src-js"><code><span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">sum_tc</span>(<span style="color: #3548cf;">xs</span>) {
    <span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">inner</span>(<span style="color: #3548cf;">xs</span>, <span style="color: #3548cf;">acc</span>) {
        <span style="color: #005e8b; font-weight: bold;">if</span> (xs.length == 0) {
            <span style="color: #005e8b; font-weight: bold;">return</span> acc;
        } <span style="color: #005e8b; font-weight: bold;">else</span> {
            <span style="color: #005e8b; font-weight: bold;">return</span> inner(xs.slice(1), acc + xs[0]);
        }        
    }
    <span style="color: #005e8b; font-weight: bold;">return</span> inner(xs, 0);
}
</code></pre>
</div>

<p>
Here, the inner function&rsquo;s recursion point is considered a tail call because
once the recursion has returned, we immediately return. This lack of extra work
means we don&rsquo;t have to allocate a new stack frame with our local variables and
can just reuse the inherited continuation.
</p>

<div class="org-src-container">
<pre class="src src-js"><code><span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">sum_tc_cps</span>(<span style="color: #3548cf;">xs</span>, <span style="color: #3548cf;">ret</span>) {
    <span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">inner</span>(<span style="color: #3548cf;">xs</span>, <span style="color: #3548cf;">acc</span>, <span style="color: #3548cf;">ret</span>) {
        <span style="color: #005e8b; font-weight: bold;">if</span> (xs.length == 0) {
            ret(acc);
        } <span style="color: #005e8b; font-weight: bold;">else</span> {
            <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">No new continuation is created here
</span>            inner(xs.slice(1), acc + xs[0], ret);
        }        
    }
    inner(xs, 0, ret);
}
</code></pre>
</div>

<p>
This means that the runtime behaviour of tail calls in cps code is essentially
identical to a loop&rsquo;s. We can recurse as much as we want, it won&rsquo;t blow up the
call stack and won&rsquo;t require more memory<span class="sidenote-ref"
    onclick="this.nextElementSibling.classList.toggle('active')">1</span><span
    class="sidenote"><sup>1</sup>
In a language with no tail call optimization, we would also need to use a
<a href="https://en.wikipedia.org/wiki/Trampoline_(computing)#High-level_programming">trampoline</a> to keep the &ldquo;regular&rdquo; call stack a a fixed depth.
</span>.
</p>

<p>
While this presentation is quite annoying to write, it lets us bypass stack
limits, add exceptions, generators and other useful fancy control
operators into any language that lets us create anonymous functions.
</p>
</div>
</div>
</div>
<div id="outline-container-org546cda7" class="outline-2">
<h2 id="org546cda7"><span class="section-number-2">3.</span> Examples</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orge94062e" class="outline-3">
<h3 id="orge94062e"><span class="section-number-3">3.1.</span> Implementing exceptions</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Let&rsquo;s imagine Javascript doesn&rsquo;t have exceptions and that we have (in
preparation for this) written our entire program in cps. How do we implement, as
a function, the <code class="src src-s">try</code>/ <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">catch</span></code> construct? Here is roughly how we do
it:
</p>

<ol class="org-ol">
<li>The construct relies on a global variable <code class="src src-js">current_exception_handler</code> to work.</li>
<li>The function takes a function to execute (the body), it takes an error
callback (the catch block) and it takes the continuation.</li>
<li>Before calling the main function to execute, it swaps out the current
exception handler for a new one. This new exception handler, when called,
will execute the &ldquo;error callback&rdquo;, reinstall the old exception handler and
finally jump to the <code class="src src-js">with_exception_handler</code> continuation.</li>
<li>Then, it calls the body with as its continuation, code that reinstalls the
old exception handler and jumps to the <code class="src src-js">with_exception_handler</code>
continuation.</li>
</ol>

<div class="org-src-container">
<pre class="src src-js" id="orgf31adcd"><code><span style="color: #005e8b; font-weight: bold;">let</span> <span style="color: #3548cf;">current_exception_handler</span> = <span style="color: #531ab6;">null</span>;

<span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">with_exception_handler</span>(<span style="color: #3548cf;">thunk</span>, <span style="color: #3548cf;">handler</span>, <span style="color: #3548cf;">ret</span>) {
    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">save the current exception handler
</span>    <span style="color: #005e8b; font-weight: bold;">const</span> <span style="color: #3548cf;">old_exception_handler</span> = current_exception_handler;
    current_exception_handler = (exn) =&gt; {
        <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Reinstall the old exception handler
</span>        current_exception_handler = old_exception_handler;
        handler(exn, ret);
    };
    thunk((thunk_retval) =&gt; {
        <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Reinstall the old exception handler
</span>        current_exception_handler = old_exception_handler;

        <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">and continue the execution through the main continuation
</span>        ret(thunk_retval);
    })
}
</code></pre>
</div>

<p>
The implementation of throw is quite simple. We just call the current exception
handler with the exception. Notice that this function doesn&rsquo;t take a
continuation parameter. This is because this function doesn&rsquo;t return.
</p>

<div class="org-src-container">
<pre class="src src-js" id="org20dc711"><code><span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">throw_exception</span>(<span style="color: #3548cf;">exn</span>) {
    current_exception_handler(exn);
}
</code></pre>
</div>

<p>
Finally, let&rsquo;s test our implementation on a simple division function that errors
out when attempting to divide by zero.
</p>

<div class="org-src-container">
<pre class="src src-js" id="org0ac7712"><code><span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">safe_div</span>(<span style="color: #3548cf;">num</span>, <span style="color: #3548cf;">denum</span>, <span style="color: #3548cf;">ret</span>)  {
    <span style="color: #005e8b; font-weight: bold;">if</span> (denum == 0) {
        throw_exception(<span style="color: #a0132f;">"division by zero"</span>)
    } <span style="color: #005e8b; font-weight: bold;">else</span> {
        ret(num/denum)
    }
}


<span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">this one will fail
</span>with_exception_handler(
    (ret) =&gt; {
        safe_div(1.0, 0.0, (r1) =&gt; {
            ret(r1);
        })
    },
    (exn, ret) =&gt; {
        console.log(<span style="color: #a0132f;">"got an exception:"</span>, exn);
        <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">We return null to signal it didn't work.
</span>        ret(<span style="color: #531ab6;">null</span>)
    },
    (result) =&gt; {
        console.log(<span style="color: #a0132f;">"got result:"</span>, result);
    }
)

with_exception_handler(
    (ret) =&gt; {
        safe_div(1.0, 2.0, (r1) =&gt; {
            ret(r1);
        })
    },
    (exn, ret) =&gt; {
        console.log(<span style="color: #a0132f;">"got an exception:"</span>, exn);
        <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">We return null to signal it didn't work.
</span>        ret(<span style="color: #531ab6;">null</span>)
    },
    (result) =&gt; {
        console.log(<span style="color: #a0132f;">"got result:"</span>, result);
    }
)

</code></pre>
</div>

<p>
when executing this code, we get:
</p>

<pre class="example">
got an exception: division by zero
got result: null
got result: 0.5
</pre>
</div>
</div>
<div id="outline-container-org0cc2ca8" class="outline-3">
<h3 id="org0cc2ca8"><span class="section-number-3">3.2.</span> Implementing call/cc</h3>
<div class="outline-text-3" id="text-3-2">
<p>
<code class="src src-scheme">call/cc</code>, or <code class="src src-scheme">call-with-current-continuation</code> is a
primitive that lets the programmer access the current continuation <b>without
having to write everything in cps</b>. However, it is trivial to implement this
operator in cps Javascript. Just call a function and give it as a parameter the
current continuation.
</p>

<div class="org-src-container">
<pre class="src src-js"><code><span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">callcc</span>(<span style="color: #3548cf;">handler</span>, <span style="color: #3548cf;">ret</span>) {
    handler(ret, ret)
}
</code></pre>
</div>

<p>
Now that we understand the usefulness of having access to the continuation of
every function call (through exploring patterns in CPS Javascript), we can move
on to a language that exposes the current continuation to the programmer
directly.
</p>
</div>
</div>
</div>
<div id="outline-container-orga77cd2e" class="outline-2">
<h2 id="orga77cd2e"><span class="section-number-2">4.</span> <code class="src src-scheme">call-with-current-continuation</code> in scheme</h2>
<div class="outline-text-2" id="text-4">
<p>
The way <code class="src src-scheme">call-with-current-continuation</code> (abbreviated as
<code class="src src-scheme">call/cc</code>) works is by receiving a callback and calling it while
giving it its continuation.
</p>


<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 5: </span>If the thunk inside call/cc returns, call/cc returns the same thing.</label><pre class="src src-scheme"><code>(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">value</span> (<span style="color: #005e8b; font-weight: bold;">call/cc</span> (<span style="color: #005e8b; font-weight: bold;">lambda</span> (ret) 1)))
(format #t <span style="color: #a0132f;">"value is ~a\n"</span> value)
</code></pre>
</div>

<pre class="example">
value is 1
</pre>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 6: </span>If the thunk does an early exit to the continuation, call/cc returns that result.</label><pre class="src src-scheme"><code>(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">value</span>
  (<span style="color: #005e8b; font-weight: bold;">call/cc</span> (<span style="color: #005e8b; font-weight: bold;">lambda</span> (ret)
             (ret <span style="color: #a0132f;">"skipped"</span>)
             (display <span style="color: #a0132f;">"tree\n"</span>)
             (display <span style="color: #a0132f;">"four\n"</span>))))

(format #t <span style="color: #a0132f;">"value is ~a\n"</span> value)
</code></pre>
</div>

<pre class="example">
value is skipped
</pre>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 7: </span>The thunk can store or return the continuation. It stays valid outside call/cc.</label><pre class="src src-scheme"><code>(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">value</span> (<span style="color: #005e8b; font-weight: bold;">call/cc</span> (<span style="color: #005e8b; font-weight: bold;">lambda</span> (ret) ret)))
(format #t <span style="color: #a0132f;">"value is ~a\n"</span> value)
(<span style="color: #005e8b; font-weight: bold;">if</span> (procedure? value)
    (value <span style="color: #a0132f;">"go back!"</span>))
</code></pre>
</div>


<p>
Using this primitive, it is possible to do everything that was doable in CPS,
but without having to actually write ugly CPS code<span class="sidenote-ref"
    onclick="this.nextElementSibling.classList.toggle('active')">2</span><span
    class="sidenote"><sup>2</sup>
The <code class="src src-scheme">call/cc</code> operator, however has flaws. Systems written using
this operator don&rsquo;t compose very well and over the years, proposals have been
made for continuations that don&rsquo;t capture the entirety of program flow. Those
continuations are called delimited.
</span> and endure callback
hell.
</p>
</div>
</div>
<div id="outline-container-org92a0790" class="outline-2">
<h2 id="org92a0790"><span class="section-number-2">5.</span> Delimited continuations</h2>
<div class="outline-text-2" id="text-5">
<p>
Since in CPS Javascript we use anonymous functions (in CPS Javascript) to
represent continuations, we jump to them by using function calls
<code class="src src-js">cont(result)</code>. However these function calls never return! Wouldn&rsquo;t it be
nice to be able to capture continuations that end somewhere? They would behave
just like normal functions!
</p>

<p>
Delimited continuations are exactly that. On top of being callable with a value,
they end at some point and return a value. Because those continuations don&rsquo;t capture the entire
execution of the program, they play well with each other and with other
constructs. Let&rsquo;s see them in action through the <code class="src src-scheme">call-with-prompt</code>
and <code class="src src-scheme">abort-to-prompt</code> scheme operators.
</p>
</div>
</div>
<div id="outline-container-org5d64355" class="outline-2">
<h2 id="org5d64355"><span class="section-number-2">6.</span> <code class="src src-scheme">call-with-prompt</code> and <code class="src src-scheme">abort-to-prompt</code></h2>
<div class="outline-text-2" id="text-6">
<p>
In <a href="https://www.gnu.org/software/guile/">Guile Scheme</a>, delimited continuations are created through two procedures.
</p>

<dl class="org-dl">
<dt><code class="src src-scheme">call-with-prompt</code></dt><dd>You use it together with a special value (a
tag) to delimit the <b>end</b> of the continuation you want to take.</dd>
<dt><code class="src src-scheme">abort-to-prompt</code></dt><dd>You use it together with the tag to define the
location at which continuation will <b>start</b>.</dd>
</dl>

<div class="org-src-container">
<pre class="src src-scheme"><code>(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">tag</span> (make-prompt-tag))

(<span style="color: #005e8b; font-weight: bold;">call-with-prompt</span> tag
  <span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">The body
</span>  (<span style="color: #005e8b; font-weight: bold;">lambda</span> ()
    <span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">abort-to-prompt returns a value!
</span>    (<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">val</span> (abort-to-prompt tag <span style="color: #a0132f;">"skipped"</span>))
    (format #t <span style="color: #a0132f;">"val: ~a\n"</span> val)
    (+ val 1))
  (<span style="color: #005e8b; font-weight: bold;">lambda</span> (kont v)
    (format #t <span style="color: #a0132f;">"we received: ~a\n"</span> v)
    (format #t <span style="color: #a0132f;">"kont(1) = ~a\n"</span> (kont 1))
    (format #t <span style="color: #a0132f;">"kont(2) = ~a\n"</span> (kont 2))))
</code></pre>
</div>

<p>
The first argument of <code class="src src-scheme">call-with-prompt</code> (the tag) is necessary for
having multiple nested <code class="src src-scheme">call-with-prompt</code>, but I won&rsquo;t talk much about
it here. The second argument is a zero argument function (thunk) which will
delimit the end of the captured continuation. The third argument is a handler
and will receive the continuation and whatever the <code class="src src-scheme">abort-to-prompt</code>
gets called with.
</p>

<p>
The <code class="src src-scheme">call-with-prompt</code> operator is very similar to exception handling
constructs in Javascript. If <code class="src src-scheme">(abort-to-prompt tag)</code> is called inside
the body, the program jumps to the handler which is given the delimited
continuation from the <code class="src src-scheme">abort-to-prompt</code> to the end of the body. Like
the non delimited variant, the continuation object can even be called multiple
times!.
</p>
</div>
</div>
<div id="outline-container-orgb3b68dc" class="outline-2">
<h2 id="orgb3b68dc"><span class="section-number-2">7.</span> <code>async</code> / <code>await</code> syntax for any monad</h2>
<div class="outline-text-2" id="text-7">
<p>
Now that we understand better the concept of continuation, let&rsquo;s use it to
analyze what the <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">await</span></code> keyword does.
</p>

<p>
One familiar with promises will know that writing this
</p>

<div class="org-src-container">
<pre class="src src-js"><code><span style="color: #005e8b; font-weight: bold;">async</span> <span style="color: #005e8b; font-weight: bold;">function</span> do_something() {

    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Some code before the await
</span>
    <span style="color: #005e8b; font-weight: bold;">const</span> <span style="color: #3548cf;">x</span> = <span style="color: #005e8b; font-weight: bold;">await</span> returns_promise();

    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Some code after the await
</span>
    <span style="color: #005e8b; font-weight: bold;">return</span> y;
}
</code></pre>
</div>

<p>
is equivalent to writing that:
</p>

<div class="org-src-container">
<pre class="src src-js"><code><span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">do_something</span>() {
    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Some code before the await
</span>
    returns_promise().then(x =&gt; {

        <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Some code after the await
</span>
        <span style="color: #005e8b; font-weight: bold;">return</span> y;
    })
}
</code></pre>
</div>

<p>
The part that is passed to the <code class="src src-js">.then</code> (the callback) is actually the
continuation starting from the <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">await</span></code> and ending when the <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">async</span></code>
function ends. If we have some kind of <code class="src src-js">.then</code> operator (called <code>&gt;&gt;=</code> or
<code>bind</code> in Haskell), each time we <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">await</span></code> an effectful value, we can capture
the current delimited continuation (from the <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">await</span></code> to the <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">async</span></code>)
and use it as a handler for the value through our <code>.then</code> function.
</p>

<p>
Let&rsquo;s use this technique to implement nondeterministic computation.
</p>
</div>
</div>
<div id="outline-container-orgd9a192c" class="outline-2">
<h2 id="orgd9a192c"><span class="section-number-2">8.</span> The <code class="src src-haskell"><span style="color: #531ab6; font-weight: bold;">List</span></code> monad</h2>
<div class="outline-text-2" id="text-8">
<p>
One way of modeling nondeterministic computation is through lists. Each time we
want to say &ldquo;this value contains a superposition of many <code class="src src-haskell"><span style="color: #531ab6; font-weight: bold;">Int</span></code>s&rdquo;, we
will say <code class="src src-haskell">[<span style="color: #531ab6; font-weight: bold;">Int</span>]</code>. When we want to model a nondeterministic
computation on <code class="src src-haskell"><span style="color: #531ab6; font-weight: bold;">Int</span></code>s (let&rsquo;s say, into strings), we use
<code class="src src-haskell"><span style="color: #531ab6; font-weight: bold;">Int</span> <span style="color: #3548cf;">-&gt;</span> [<span style="color: #531ab6; font-weight: bold;">String</span>]</code>. we combine those two values through first applying
the function to each possible value (getting a <code class="src src-haskell">[[<span style="color: #531ab6; font-weight: bold;">String</span>]]</code>), then by
flattening the lists together into a <code class="src src-haskell">[<span style="color: #531ab6; font-weight: bold;">String</span>]</code>. When implemented in
Scheme, it looks like this:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 8: </span>For wrapping a determinstic value and for threading a nondeterministic value through a nondeterministic computation.</label><pre class="src src-scheme"><code>(<span style="color: #005e8b; font-weight: bold;">define</span> (<span style="color: #8f0075;">.then</span> l func)
  (apply append (<span style="color: #005e8b; font-weight: bold;">map</span> func l)))

(<span style="color: #005e8b; font-weight: bold;">define</span> (<span style="color: #8f0075;">pure</span> x)
  (list x))
</code></pre>
</div>

<p>
Actually implementing the syntax is slightly more tricky.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><code>(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">prompt-tag</span> (make-prompt-tag))

<span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">Awaiting a value (choosing a value among nondeterministic choices)
</span><span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">is simple, just abort to the nearest handler and give the list.
</span>(<span style="color: #005e8b; font-weight: bold;">define</span> (<span style="color: #8f0075;">await</span> mval)
  (abort-to-prompt prompt-tag
                   mval))

<span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">When the continuation is to be threaded using nondeterministic
</span><span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">value (a list of things), we use .then on the continuation while
</span><span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">making sure we re-delimit the end of the continuation using another
</span><span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">async block.
</span>(<span style="color: #005e8b; font-weight: bold;">define</span> (<span style="color: #8f0075;">async</span> thunk)
  (<span style="color: #005e8b; font-weight: bold;">call-with-prompt</span> prompt-tag
    thunk
    (<span style="color: #005e8b; font-weight: bold;">lambda</span> (cont value)
      (.then value (<span style="color: #005e8b; font-weight: bold;">lambda</span> (v)
                   (async
                    (<span style="color: #005e8b; font-weight: bold;">lambda</span> ()
                      (cont v))))))))
</code></pre>
</div>

<p>
Finally we can test our code on a toy example. Here, a sequential nondeterminist
choice of number, letter and fruit should yield every combination of number,
letter and fruit.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><code>(<span style="color: #005e8b; font-weight: bold;">use-modules</span> (ice-9 pretty-print))

(pretty-print
 (async
  (<span style="color: #005e8b; font-weight: bold;">lambda</span> ()
    (<span style="color: #005e8b; font-weight: bold;">let</span> ((num (await '(1 2 3)))
          (letter (await '(a b c)))
          (fruit (await '(<span style="color: #a0132f;">"apple"</span> <span style="color: #a0132f;">"orange"</span> <span style="color: #a0132f;">"banana"</span>))))
      (pure (list num letter fruit))))))
</code></pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme"><code>((1 a <span style="color: #a0132f;">"apple"</span>)
 (1 a <span style="color: #a0132f;">"orange"</span>)
 (1 a <span style="color: #a0132f;">"banana"</span>)
 (1 b <span style="color: #a0132f;">"apple"</span>)
 (1 b <span style="color: #a0132f;">"orange"</span>)
 (1 b <span style="color: #a0132f;">"banana"</span>)
 (1 c <span style="color: #a0132f;">"apple"</span>)
 (1 c <span style="color: #a0132f;">"orange"</span>)
 (1 c <span style="color: #a0132f;">"banana"</span>)
 (2 a <span style="color: #a0132f;">"apple"</span>)
 (2 a <span style="color: #a0132f;">"orange"</span>)
 (2 a <span style="color: #a0132f;">"banana"</span>)
 (2 b <span style="color: #a0132f;">"apple"</span>)
 (2 b <span style="color: #a0132f;">"orange"</span>)
 (2 b <span style="color: #a0132f;">"banana"</span>)
 (2 c <span style="color: #a0132f;">"apple"</span>)
 (2 c <span style="color: #a0132f;">"orange"</span>)
 (2 c <span style="color: #a0132f;">"banana"</span>)
 (3 a <span style="color: #a0132f;">"apple"</span>)
 (3 a <span style="color: #a0132f;">"orange"</span>)
 (3 a <span style="color: #a0132f;">"banana"</span>)
 (3 b <span style="color: #a0132f;">"apple"</span>)
 (3 b <span style="color: #a0132f;">"orange"</span>)
 (3 b <span style="color: #a0132f;">"banana"</span>)
 (3 c <span style="color: #a0132f;">"apple"</span>)
 (3 c <span style="color: #a0132f;">"orange"</span>)
 (3 c <span style="color: #a0132f;">"banana"</span>))
</code></pre>
</div>

<p>
It works! Note that for the types to work, the output of every <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">async</span></code>
thunk must be wrapped into a monadic value. You do not have to do this when
using Javascript promises simply because it is done automatically. Note that you
can use the exact same code for every monad, just change the definition of
<code class="src src-scheme">.then</code> and <code class="src src-scheme">pure</code>. You can use this code to ease the
implementation of monadic parser combinators, promises (which is just, as we
have seen, continuation passing style) and other effects.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
In a language with no tail call optimization, we would also need to use a
<a href="https://en.wikipedia.org/wiki/Trampoline_(computing)#High-level_programming">trampoline</a> to keep the &ldquo;regular&rdquo; call stack a a fixed depth.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
The <code class="src src-scheme">call/cc</code> operator, however has flaws. Systems written using
this operator don&rsquo;t compose very well and over the years, proposals have been
made for continuations that don&rsquo;t capture the entirety of program flow. Those
continuations are called delimited.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Date: 2024-05-26 Sun 00:00</p>
<p class="author">Author: Justin Veilleux</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
