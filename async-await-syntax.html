<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="english" xml:lang="english">
<head>
<!-- 2024-09-15 Sun 21:36 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Implementing ~async~-~await~ syntax using delimited continuations</title>
<meta name="author" content="Justin Veilleux" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Implementing <code>async</code>-<code>await</code> syntax using delimited continuations</h1>
<p>
When we are writing Haskell code and we need access to weird control operators
(such as <code>call/cc</code>), we usually use the <a href="https://www.haskellforall.com/2012/12/the-continuation-monad.html">continuation monad</a>. Because of Haskell's
<code>do</code> notation, having to write monadic code to get control operators is not so
bad. However, it turns out that if you already have access to some of those
weird control operators, you can get back the syntactic sugar.
</p>

<p>
I won't go into what the continuation monad is (or why one would want to use
it), but I will talk about the general principle of monads. Here is the
definition of a monad in haskell:
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #005e8b; font-weight: bold;">class</span> <span style="color: #531ab6; font-weight: bold;">Monad</span> f <span style="color: #005e8b; font-weight: bold;">where</span>
  return <span style="color: #3548cf;">::</span> x <span style="color: #3548cf;">-&gt;</span> f x
  bind <span style="color: #3548cf;">::</span> f x <span style="color: #3548cf;">-&gt;</span> (x <span style="color: #3548cf;">-&gt;</span> f y) <span style="color: #3548cf;">-&gt;</span> f y
</pre>
</div>

<p>
Monads are useful to model effects. Such an effect can be nondeterminism (the
<code class="src src-haskell"><span style="color: #531ab6; font-weight: bold;">List</span></code> monad), partiality (the <code class="src src-haskell"><span style="color: #531ab6; font-weight: bold;">Maybe</span></code> monad),
statefulness (the <code class="src src-haskell"><span style="color: #531ab6; font-weight: bold;">State</span></code> monad), or even delayed computation (the
<code class="src src-haskell"><span style="color: #531ab6; font-weight: bold;">Cont</span></code> monad). In the above definition, the <code class="src src-haskell">return</code>
function would wrap a pure value without effects whereas the <code class="src src-haskell">bind</code>
function would thread effectful computations.
</p>

<div id="outline-container-orge7ca432" class="outline-2">
<h2 id="orge7ca432"><span class="section-number-2">1.</span> <code>async</code> and <code>await</code> in Javascript</h2>
<div class="outline-text-2" id="text-1">
<p>
One very popular monad (it is very much used outside the functional programming
community) is the concept of promise. A promise is a value that you do not yet
have, but that you want to manipulate. For instance, the javascript
<code class="src src-js">fetch</code> function returns promises which you manipulate through the
<code class="src src-js">.then</code> method:
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #005e8b; font-weight: bold;">const</span> <span style="color: #3548cf;">resp_promise</span> = fetch(<span style="color: #a0132f;">"http://example.org/"</span>);
resp_promise.then(resp =&gt; {
    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Something ...</span>
    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">...</span>
})
</pre>
</div>

<p>
As any web developper knows, using <code class="src src-js">.then</code> for managing sequential
promises make for very ugly code:
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #005e8b; font-weight: bold;">const</span> <span style="color: #3548cf;">resp_promise</span> = fetch(<span style="color: #a0132f;">"http://example.org/"</span>);
resp_promise.then(resp =&gt; {
    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Something ...</span>
    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">...</span>
    something.then(value =&gt; {
        <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">...</span>
        something_else.then(x =&gt; {
            <span style="color: #595959; font-style: italic;">//</span><span style="color: #595959; font-style: italic;">...</span>
        })
    })
})
</pre>
</div>

<p>
Javascript's solution to this problem is <code>async</code> and <code>await</code>. Using <code>await</code> on a
promise will make the program look as if it is waiting for the result and <code>async</code>
marks a function in which you would like to use <code>await</code>. It turns out that this
piece of syntactic sugar is the same as the more general <code>do</code> notation in Haskell.
Because the <code>await</code> keyword is familiar to many people, I will reuse it as a <code>bind</code>
operator in the rest of the article. Because the <code>await</code> keyword essentially puts
the delimited continuation from a point to the end of the <code>async</code> function into
the <code class="src src-js">.then</code>, we can recreate the same behaviour by manually capturing this
said delimited continuation.
</p>
</div>
</div>

<div id="outline-container-orgd436a64" class="outline-2">
<h2 id="orgd436a64"><span class="section-number-2">2.</span> The concept of continuation</h2>
<div class="outline-text-2" id="text-2">
<p>
Before we dive into the technical details of implementing <code>async</code> / <code>await</code> syntax,
let me first explain what continuations are. The concept of a continuation
captures the idea of "the rest of the program" from a certain point. Let's say
an interpreter is evaluating the following expression and has just finished
calculating the <code class="src src-js">b*b - 4 * a * c</code> sub expression.
</p>

<div class="org-src-container">
<pre class="src src-js">(-b + sqrt(b*b - 4 * a * c))/(2*a)
</pre>
</div>

<p>
The state of the interpreter holds the computed value (the results of evaluating
<code class="src src-js">b*b - 4 * a * c</code> ) and what to do with it after. That information is the
continuation. Thinking about continuations is useful for writing compilers, but
it is also useful in other contexts. For instance, there is a certain program
transformation (called Continuation-Passing-Style conversion) where every
<code class="src src-js"><span style="color: #005e8b; font-weight: bold;">return</span></code> keyword is eliminated and where every function call takes a new
parameter, its continuation. For instance, let's CPS-convert the <code class="src src-js">fib</code>
function.
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">fib</span>(<span style="color: #3548cf;">n</span>) {
    <span style="color: #005e8b; font-weight: bold;">if</span> (n &lt;= 1) {
        <span style="color: #005e8b; font-weight: bold;">return</span> n
    } <span style="color: #005e8b; font-weight: bold;">else</span> {
        <span style="color: #005e8b; font-weight: bold;">return</span> fib(n - 1) + fib(n-2);
    }
}

console.log(fib(5))
</pre>
</div>

<pre class="example">
5
</pre>


<p>
It becomes the following:
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">fib_cps</span>(<span style="color: #3548cf;">n</span>, <span style="color: #3548cf;">ret</span>) {
    <span style="color: #005e8b; font-weight: bold;">if</span> (n &lt;= 1) {
        ret(n);
    } <span style="color: #005e8b; font-weight: bold;">else</span> {
        fib_cps(n - 1, r1 =&gt; {
            fib_cps(n - 2, r2 =&gt; {
                ret(r1 + r2);
            })
        })
    }
}

fib_cps(5, res =&gt; {
    console.log(res);
})
</pre>
</div>

<pre class="example">
5
</pre>


<p>
Notice that instead of using <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">return</span></code>, we call a function that is
explicitely passed as a parameter to <code class="src src-js">fib_cps</code>. Moreover, each time we
call a function, we must act as if it will never return (it will not) and pass a
handler (a continuation) that contains the rest of the computation. Notice that
in the above code, after having computed the results for \( n - 1 \) and \( n -
2 \), the results is passed to the continuation of the main call which is
<code class="src src-js">ret</code>.
</p>

<p>
While this presentation is quite annoying to write, it lets us add exceptions,
generators and other useful fancy control operators into languages that only
support passing functions around.
</p>
</div>
</div>

<div id="outline-container-org93f555d" class="outline-2">
<h2 id="org93f555d"><span class="section-number-2">3.</span> Examples</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgd0d8c68" class="outline-3">
<h3 id="orgd0d8c68"><span class="section-number-3">3.1.</span> Implementing exceptions</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">
<pre class="src src-js"><span style="color: #005e8b; font-weight: bold;">let</span> <span style="color: #3548cf;">exception_handler</span> = <span style="color: #531ab6;">null</span>;

<span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">When implementing try/catch, we want to:</span>
<span style="color: #595959; font-style: italic;">//</span>
<span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">1. save the current exception handler function</span>
<span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">2. replace the exception handler function by the one given by the user.</span>
<span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">3. Execute the thunk with the appropriate continuation</span>
<span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">4. If throw_exception was called, resume the computation through the `ret` continuation.</span>
<span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">with_exception_handler</span>(<span style="color: #3548cf;">thunk</span>, <span style="color: #3548cf;">handler</span>, <span style="color: #3548cf;">ret</span>) {
    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">save the current exception handler</span>
    <span style="color: #005e8b; font-weight: bold;">const</span> <span style="color: #3548cf;">old_exception_handler</span> = exception_handler;
    exception_handler = (exn) =&gt; {
        <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Reinstall the old exception handler</span>
        exception_handler = old_exception_handler;
        handler(exn, ret);
    };
    thunk((thunk_retval) =&gt; {
        <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Reinstall the old exception handler</span>
        exception_handler = old_exception_handler;
        <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">and continue the execution through the main continuation</span>
        ret(thunk_retval);
    })
}

<span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Notice that contrary to every function in CPS, this one doesn't</span>
<span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">have a "continuation" parameter.</span>
<span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">throw_exception</span>(<span style="color: #3548cf;">value</span>) {
    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Inside, we just call the exception handler.</span>
    exception_handler(value);
}


<span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">safe_div</span>(<span style="color: #3548cf;">num</span>, <span style="color: #3548cf;">denum</span>, <span style="color: #3548cf;">ret</span>)  {
    <span style="color: #005e8b; font-weight: bold;">if</span> (denum == 0) {
        throw_exception(<span style="color: #a0132f;">"division by zero"</span>)
    } <span style="color: #005e8b; font-weight: bold;">else</span> {
        ret(num/denum)
    }
}


with_exception_handler(
    (ret) =&gt; {
        safe_div(0.0, 2.0, (r1) =&gt; {
            safe_div(1.0, r1, (r2) =&gt; {
                ret(r2);
            })
        })
    },
    (exn, ret) =&gt; {
        console.log(<span style="color: #a0132f;">"got an exception:"</span>, exn);
        <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">We return null to signal it didn't work.</span>
        ret(<span style="color: #531ab6;">null</span>)
    },
    (result) =&gt; {
        console.log(<span style="color: #a0132f;">"got result:"</span>, result);
    }
)
</pre>
</div>

<pre class="example">
got an exception: division by zero
got result: null
</pre>
</div>
</div>

<div id="outline-container-org05cdccc" class="outline-3">
<h3 id="org05cdccc"><span class="section-number-3">3.2.</span> Implementing call/cc</h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">
<pre class="src src-js"><span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">callcc</span>(<span style="color: #3548cf;">handler</span>, <span style="color: #3548cf;">ret</span>) {
    handler(ret, ret)
}
</pre>
</div>


<p>
Implementing <code class="src src-scheme">call/cc</code> in CPS is very easy, because CPS exposes every
continuation in an explicit variable. Understanding this control operator,
though, will be useful, because it is often the operator used by languages to
reify continuations and expose them to the user <b>without forcing them to write
everything in CPS!</b>
</p>
</div>
</div>
</div>

<div id="outline-container-orgbfa0bb7" class="outline-2">
<h2 id="orgbfa0bb7"><span class="section-number-2">4.</span> <code class="src src-scheme">call/cc</code> in scheme</h2>
<div class="outline-text-2" id="text-4">
<p>
The way <code class="src src-scheme">call/cc</code> works is that it gives as an argument to the thunk
the function capturing the continuation exiting the block. Let's see how it
works in scheme.
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">value</span>
  (<span style="color: #005e8b; font-weight: bold;">call/cc</span> (<span style="color: #005e8b; font-weight: bold;">lambda</span> (ret)
             (display <span style="color: #a0132f;">"one\n"</span>)
             (display <span style="color: #a0132f;">"two\n"</span>)
             (ret 12345)
             (display <span style="color: #a0132f;">"tree\n"</span>)
             (display <span style="color: #a0132f;">"four\n"</span>))))

(format #t <span style="color: #a0132f;">"value is ~a\n"</span> value)
</pre>
</div>

<pre class="example">
one
two
value is 12345
</pre>


<p>
Using this primitive, it is possible to do pretty much everything that was
doable in CPS, but without having to actually write CPS code (and endure a
thousand levels of nesting).
</p>
</div>

<div id="outline-container-org870cd5f" class="outline-3">
<h3 id="org870cd5f"><span class="section-number-3">4.1.</span> Note</h3>
<div class="outline-text-3" id="text-4-1">
<p>
It might be very confusing at first, (because up until now, our use of
continuations have respected scope), but you can reinstall a continuation <b>after
you have executed it</b>. This lets you (for instance) do backtracking and other
things.
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">kont</span>
  (<span style="color: #005e8b; font-weight: bold;">call/cc</span> (<span style="color: #005e8b; font-weight: bold;">lambda</span> (k) k)))

(display <span style="color: #a0132f;">"exited call/cc block\n"</span>)

(<span style="color: #005e8b; font-weight: bold;">if</span> (procedure? kont)
    (<span style="color: #005e8b; font-weight: bold;">begin</span>
      (display <span style="color: #a0132f;">"hello\n"</span>)
      (kont 123))
    (format #t <span style="color: #a0132f;">"the value: ~a\n"</span> kont))
</pre>
</div>

<pre class="example">
exited call/cc block
hello
exited call/cc block
the value: 123
</pre>
</div>
</div>

<div id="outline-container-org7404f43" class="outline-3">
<h3 id="org7404f43"><span class="section-number-3">4.2.</span> Problems with <code class="src src-scheme">call/cc</code></h3>
<div class="outline-text-3" id="text-4-2">
<p>
The <code class="src src-scheme">call/cc</code> operator, however has flaws. Systems written using this
operator don't compose very well and over the years, proposals have been made
for continuations that don't capture the entirety of program flow. Those
continuations are called delimited.
</p>
</div>
</div>
</div>


<div id="outline-container-org71b563d" class="outline-2">
<h2 id="org71b563d"><span class="section-number-2">5.</span> Delimited continuations</h2>
<div class="outline-text-2" id="text-5">
<p>
Delimited continuations are continuations that end with a value, their
reification in functions are more natural because <b>they are reified into
functions that return something</b>. Because those continuations don't capture the
entire execution of the program, they play well with each other and with other
constructs. Let's see them in action through the <code class="src src-scheme">call-with-prompt</code>
and <code class="src src-scheme">abort-to-prompt</code> scheme operators.
</p>
</div>
</div>

<div id="outline-container-org41ddb65" class="outline-2">
<h2 id="org41ddb65"><span class="section-number-2">6.</span> <code class="src src-scheme">call-with-prompt</code> and <code class="src src-scheme">abort-to-prompt</code></h2>
<div class="outline-text-2" id="text-6">
<p>
In <a href="https://www.gnu.org/software/guile/">Guile Scheme</a>, delimited continuations are created through two procedures.
</p>

<dl class="org-dl">
<dt><code class="src src-scheme">call-with-prompt</code></dt><dd>You use it together with a special value (a
tag) to delimit the <b>end</b> of the continuation you want to take.</dd>
<dt><code class="src src-scheme">abort-to-prompt</code></dt><dd>You use it together with the tag to define the
location at which continuation will <b>start</b>.</dd>
</dl>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">tag</span> (make-prompt-tag))

(<span style="color: #005e8b; font-weight: bold;">call-with-prompt</span> tag
  (<span style="color: #005e8b; font-weight: bold;">lambda</span> ()
    (<span style="color: #005e8b; font-weight: bold;">let</span> ((x 12345))
      <span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">...</span>
      (<span style="color: #005e8b; font-weight: bold;">let</span> ((y (+ x (abort-to-prompt tag))))
        <span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">...</span>
        y)))
  (<span style="color: #005e8b; font-weight: bold;">lambda</span> (kont)
    <span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">...</span>
    ))
</pre>
</div>

<p>
The first argument of <code class="src src-scheme">call-with-prompt</code> (the tag) is necessary for
the <code class="src src-scheme">abort-to-prompt</code> call to be able to specify which continuation to
open in situations in which multiple <code class="src src-scheme">call-with-prompt</code> are nested.
The second argument is a zero argument function (thunk) which will delimit the
end of the captured continuation. When the captured delimited continuation is
called, execution will flow from the <code class="src src-scheme">abort-to-prompt</code> call to the end
of this thunk. The third argument is the handler (kind of like <code>try</code> / <code>catch</code>) that
will be called with the created continuation when <code class="src src-scheme">abort-to-prompt</code> is
called. To better understand how it works, here is an example:
</p>

<div class="org-src-container">
<pre class="src src-scheme" id="org4b986b8">(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">tag</span> (make-prompt-tag))
(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">cont</span>
  (<span style="color: #005e8b; font-weight: bold;">call-with-prompt</span> tag
    (<span style="color: #005e8b; font-weight: bold;">lambda</span> ()
      (display <span style="color: #a0132f;">"hello!\n"</span>)
      (<span style="color: #005e8b; font-weight: bold;">let</span> ((x (abort-to-prompt tag <span style="color: #a0132f;">"some-value"</span>)))
        (+ 5 x)))
    (<span style="color: #005e8b; font-weight: bold;">lambda</span> (k val)
      (format #t <span style="color: #a0132f;">"got value: ~s\n"</span> val)
      k)))

(display (cont 1)) (newline)
(display (cont 3)) (newline)
</pre>
</div>

<p>
Here is the output of the code:
</p>

<pre class="example">
hello!
got value: "some-value"
6
8
</pre>


<p>
At first glance, we can see that, contrary to continuations captured by
<code class="src src-scheme">call/cc</code>(which act kind of like value-carrying <code>goto</code> s), these
delimited continuations return something. Another difference is that in
<code class="src src-scheme">call/cc</code>, the <code>k</code> parameter captures the continuation starting from the
<code class="src src-scheme">call/cc</code> call itself, whereas in <code class="src src-scheme">call-with-prompt</code> it
captures the continuation starting from the innermost
<code class="src src-scheme">abort-to-prompt</code> call inside the thunk.
</p>
</div>
</div>

<div id="outline-container-org2a1cc39" class="outline-2">
<h2 id="org2a1cc39"><span class="section-number-2">7.</span> <code>async</code> / <code>await</code> syntax for any monad</h2>
<div class="outline-text-2" id="text-7">
<p>
Now that we understand better the concept of continuation, let's use it to
analyze what the <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">await</span></code> keyword does.
</p>

<p>
One familiar with promises will know that writing this
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #005e8b; font-weight: bold;">async</span> <span style="color: #005e8b; font-weight: bold;">function</span> do_something() {

    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Some code before the await</span>

    <span style="color: #005e8b; font-weight: bold;">const</span> <span style="color: #3548cf;">x</span> = <span style="color: #005e8b; font-weight: bold;">await</span> returns_promise();

    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Some code after the await</span>

    <span style="color: #005e8b; font-weight: bold;">return</span> y;
}
</pre>
</div>

<p>
is equivalent to writing that:
</p>

<div class="org-src-container">
<pre class="src src-js"><span style="color: #005e8b; font-weight: bold;">function</span> <span style="color: #8f0075;">do_something</span>() {
    <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Some code before the await</span>

    returns_promise().then(x =&gt; {

        <span style="color: #595959; font-style: italic;">// </span><span style="color: #595959; font-style: italic;">Some code after the await</span>

        <span style="color: #005e8b; font-weight: bold;">return</span> y;
    })
}
</pre>
</div>

<p>
The part that is put in the <code class="src src-js">.then</code> (the callback) is actually the
continuation starting from the <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">await</span></code> and ending when the <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">async</span></code>
function ends. If we have some kind of <code class="src src-js">.then</code> operator (called <code>&gt;&gt;=</code> or
<code>bind</code> in Haskell), each time we <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">await</span></code> an effectful value, we can capture
the current delimited continuation (from the <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">await</span></code> to the <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">async</span></code>)
and use it as a handler for the value through our <code>.then</code> function.
</p>

<p>
Let's use this technique to implement nondeterministic computation.
</p>
</div>
</div>

<div id="outline-container-org3e6766a" class="outline-2">
<h2 id="org3e6766a"><span class="section-number-2">8.</span> The <code class="src src-haskell"><span style="color: #531ab6; font-weight: bold;">List</span></code> monad</h2>
<div class="outline-text-2" id="text-8">
<p>
One way of modeling nondeterministic computation is through lists. Each time we
want to say "this value contains a superposition of many <code class="src src-haskell"><span style="color: #531ab6; font-weight: bold;">Int</span></code>s", we
will say <code class="src src-haskell">[<span style="color: #531ab6; font-weight: bold;">Int</span>]</code>. When we want to model a nondeterministic
computation on <code class="src src-haskell"><span style="color: #531ab6; font-weight: bold;">Int</span></code>s (let's say, into strings), we use
<code class="src src-haskell"><span style="color: #531ab6; font-weight: bold;">Int</span> <span style="color: #3548cf;">-&gt;</span> [<span style="color: #531ab6; font-weight: bold;">String</span>]</code>. we combine those two values through first applying
the function to each possible value (getting a <code class="src src-haskell">[[<span style="color: #531ab6; font-weight: bold;">String</span>]]</code>), then by
flattening the lists together into a <code class="src src-haskell">[<span style="color: #531ab6; font-weight: bold;">String</span>]</code>. When implemented in
Scheme, it looks like this:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>For wrapping a determinstic value and for threading a nondeterministic value through a nondeterministic computation.</label><pre class="src src-scheme">(<span style="color: #005e8b; font-weight: bold;">define</span> (<span style="color: #8f0075;">.then</span> l func)
  (apply append (<span style="color: #005e8b; font-weight: bold;">map</span> func l)))

(<span style="color: #005e8b; font-weight: bold;">define</span> (<span style="color: #8f0075;">pure</span> x)
  (list x))
</pre>
</div>

<p>
Actually implementing the syntax is slightly more tricky.
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">prompt-tag</span> (make-prompt-tag))

<span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">Awaiting a value (choosing a value among nondeterministic choices)</span>
<span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">is simple, just abort to the nearest handler and give the list.</span>
(<span style="color: #005e8b; font-weight: bold;">define</span> (<span style="color: #8f0075;">await</span> mval)
  (abort-to-prompt prompt-tag
                   mval))

<span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">When the continuation is to be threaded using nondeterministic</span>
<span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">value (a list of things), we use .then on the continuation while</span>
<span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">making sure we re-delimit the end of the continuation using another</span>
<span style="color: #595959; font-style: italic;">;; </span><span style="color: #595959; font-style: italic;">async block.</span>
(<span style="color: #005e8b; font-weight: bold;">define</span> (<span style="color: #8f0075;">async</span> thunk)
  (<span style="color: #005e8b; font-weight: bold;">call-with-prompt</span> prompt-tag
    thunk
    (<span style="color: #005e8b; font-weight: bold;">lambda</span> (cont value)
      (.then value (<span style="color: #005e8b; font-weight: bold;">lambda</span> (v)
                   (async
                    (<span style="color: #005e8b; font-weight: bold;">lambda</span> ()
                      (cont v))))))))
</pre>
</div>

<p>
Finally we can test our code on a toy example. Here, a sequential nondeterminist
choice of number, letter and fruit should yield every combination of number,
letter and fruit.
</p>

<div class="org-src-container">
<pre class="src src-scheme">(<span style="color: #005e8b; font-weight: bold;">use-modules</span> (ice-9 pretty-print))

(pretty-print
 (async
  (<span style="color: #005e8b; font-weight: bold;">lambda</span> ()
    (<span style="color: #005e8b; font-weight: bold;">let</span> ((num (await '(1 2 3)))
          (letter (await '(a b c)))
          (fruit (await '(<span style="color: #a0132f;">"apple"</span> <span style="color: #a0132f;">"orange"</span> <span style="color: #a0132f;">"banana"</span>))))
      (pure (list num letter fruit))))))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme">((1 a <span style="color: #a0132f;">"apple"</span>)
 (1 a <span style="color: #a0132f;">"orange"</span>)
 (1 a <span style="color: #a0132f;">"banana"</span>)
 (1 b <span style="color: #a0132f;">"apple"</span>)
 (1 b <span style="color: #a0132f;">"orange"</span>)
 (1 b <span style="color: #a0132f;">"banana"</span>)
 (1 c <span style="color: #a0132f;">"apple"</span>)
 (1 c <span style="color: #a0132f;">"orange"</span>)
 (1 c <span style="color: #a0132f;">"banana"</span>)
 (2 a <span style="color: #a0132f;">"apple"</span>)
 (2 a <span style="color: #a0132f;">"orange"</span>)
 (2 a <span style="color: #a0132f;">"banana"</span>)
 (2 b <span style="color: #a0132f;">"apple"</span>)
 (2 b <span style="color: #a0132f;">"orange"</span>)
 (2 b <span style="color: #a0132f;">"banana"</span>)
 (2 c <span style="color: #a0132f;">"apple"</span>)
 (2 c <span style="color: #a0132f;">"orange"</span>)
 (2 c <span style="color: #a0132f;">"banana"</span>)
 (3 a <span style="color: #a0132f;">"apple"</span>)
 (3 a <span style="color: #a0132f;">"orange"</span>)
 (3 a <span style="color: #a0132f;">"banana"</span>)
 (3 b <span style="color: #a0132f;">"apple"</span>)
 (3 b <span style="color: #a0132f;">"orange"</span>)
 (3 b <span style="color: #a0132f;">"banana"</span>)
 (3 c <span style="color: #a0132f;">"apple"</span>)
 (3 c <span style="color: #a0132f;">"orange"</span>)
 (3 c <span style="color: #a0132f;">"banana"</span>))
</pre>
</div>

<p>
It works! Note that for the types to work, the output of every <code class="src src-js"><span style="color: #005e8b; font-weight: bold;">async</span></code>
thunk must be wrapped into a monadic value. You do not have to do this when
using Javascript promises simply because it is done automatically. Note that you
can use the exact same code for every monad, just change the definition of
<code class="src src-scheme">.then</code> and <code class="src src-scheme">pure</code>. You can use this code to ease the
implementation of monadic parser combinators, promises (which is just, as we
have seen, continuation passing style) and other effects.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2024-05-26 Sun 00:00</p>
<p class="author">Author: Justin Veilleux</p>
<p class="date">Created: 2024-09-15 Sun 21:36</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
