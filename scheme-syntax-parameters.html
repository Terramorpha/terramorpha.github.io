<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="english" xml:lang="english">
<head>
<!-- 2025-09-25 Thu 18:11 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Guile scheme's syntax parameters</title>
<meta name="author" content="Justin Veilleux" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  pre.src-C\+\+:before { content: 'C++'; }
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'JavaScript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="Agda.css" />
<style>.org-latex-block { margin: auto; } </style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Guile scheme's syntax parameters</h1>
<p>
One of the distinguishing features of the scheme programming language, when it
was created in 1975, was its use of lexical scoping, which departed from the
tradition of dynamic scoping of other lisps at the time.
</p>
<div id="outline-container-orge323f18" class="outline-2">
<h2 id="orge323f18"><span class="section-number-2">1.</span> Dynamic vs lexical scope</h2>
<div class="outline-text-2" id="text-1">
<p>
Since the release of scheme 50 years ago, lexical scoping has become the way (as
far as I can tell) every language does things. For this reaseon, most reader
will not know what either of these scoping rules mean and will see lexical scope
as the obvious "correct" behaviour.
</p>

<p>
Dynamic and lexical scoping differ in how they treat free variables of lambdas.
In the following code, the variabel <code class="src src-emacs-lisp">c</code> is free in the lambda as
it is not bound in the parameter list.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><code>(<span style="color: #005e8b; font-weight: bold;">setq</span> c <span style="color: #a0132f;">"something"</span>)
(<span style="color: #005e8b; font-weight: bold;">setq</span> func (<span style="color: #005e8b; font-weight: bold;">lambda</span> (a b) c))
</code></pre>
</div>

<p>
In dynamic binding, when the lambda is executed, the value of <code class="src src-emacs-lisp">c</code>
will be retrieved from the binding closest to the call site. In lexical scoping,
the value will be retrieved from the binding closest to the place where the
lambda was created.
</p>

<p>
For instance, if the following code is executed in dynamic binding:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp" id="orgefded8f"><code>(<span style="color: #005e8b; font-weight: bold;">setq</span> x <span style="color: #a0132f;">"initial-value"</span>)

(<span style="color: #005e8b; font-weight: bold;">let</span> ((some-function
       (<span style="color: #005e8b; font-weight: bold;">let</span> ((x <span style="color: #a0132f;">"modified-value"</span>))
         (<span style="color: #005e8b; font-weight: bold;">lambda</span> () x))))
  (message <span style="color: #a0132f;">"the value is %s"</span> (funcall some-function)))
</code></pre>
</div>

<p>
We get
</p>

<pre class="example">
the value is initial-value
</pre>

<p>
But if it is executed in lexical binding, we get
</p>

<pre class="example">
the value is modified-value
</pre>
</div>
</div>
<div id="outline-container-org46e5ebc" class="outline-2">
<h2 id="org46e5ebc"><span class="section-number-2">2.</span> Scheme dynamic parameters</h2>
<div class="outline-text-2" id="text-2">
<p>
Even if history has decided lexical scope is a generally better paradigm, there
are still cases where we would like to have something like special variables
that are dynamically bound. For instance, we might want to temporarily set a
global variable of a program to some value so that the "verbose" mode is
activated for some specific part of the program.
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span style="color: #3548cf;">old_verbose</span> = VERBOSE
<span style="color: #3548cf;">VERBOSE</span> = <span style="color: #531ab6;">True</span>
do_something()
<span style="color: #3548cf;">VERBOSE</span> = old_verbose
</code></pre>
</div>

<p>
This code, however is incorrect because if <code class="src src-python">do_something</code> throws an
exception, the global variable is left with the "temporary" value. What you
would want is actually:
</p>

<div class="org-src-container">
<pre class="src src-python"><code><span style="color: #3548cf;">old_verbose</span> = VERBOSE
<span style="color: #3548cf;">VERBOSE</span> = <span style="color: #531ab6;">True</span>
<span style="color: #005e8b; font-weight: bold;">try</span>:
    do_something()
<span style="color: #005e8b; font-weight: bold;">finally</span>:
    <span style="color: #3548cf;">VERBOSE</span> = old_verbose
</code></pre>
</div>

<p>
Scheme's parameters (constructed with <code class="src src-scheme">make-parameter</code>) work just like this.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><code>(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">verbose</span> (make-parameter #f))

(<span style="color: #005e8b; font-weight: bold;">define</span> (<span style="color: #8f0075;">do-something</span>)
  (<span style="color: #005e8b; font-weight: bold;">when</span> (verbose)
    (format #t <span style="color: #a0132f;">"verbose mode on\n"</span>)))


(format #t <span style="color: #a0132f;">"a:\n"</span>)
(<span style="color: #005e8b; font-weight: bold;">parameterize</span> ((verbose 1))
  (do-something))

(format #t <span style="color: #a0132f;">"b:\n"</span>)
(do-something)
</code></pre>
</div>

<pre class="example">
a:
verbose mode on
b:
</pre>

<p>
Parameters let us control explicitly where we want dynamic scope. They use
special low level runtime facilities so that they interact well with re-entrant
continuations, exceptions and all kinds of dynamic behaviour. They are used for
things such as the default text encoding or the default output port.
</p>
</div>
</div>
<div id="outline-container-org3b3fbd4" class="outline-2">
<h2 id="org3b3fbd4"><span class="section-number-2">3.</span> lexical scope as hygiene</h2>
<div class="outline-text-2" id="text-3">
<p>
One way to conceptualise lexical scope is to think of it as hygiene for
variables. Lexical scope acts as a form of access control. The free variables of
a closure are inaccessible by the caller of the closure. This lets us build an
object system using only these closures:
</p>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">Listing 1: </span>When implementing an object system using closures, the object is its own method dispatch and its state is its closure</label><pre class="src src-scheme" id="orgd69841b"><code>(<span style="color: #005e8b; font-weight: bold;">use-modules</span> (ice-9 match))

(<span style="color: #005e8b; font-weight: bold;">define</span> (<span style="color: #8f0075;">make-person</span> name age)
  (<span style="color: #005e8b; font-weight: bold;">lambda</span> msg
    (<span style="color: #005e8b; font-weight: bold;">match</span> msg
      (('get-name) name)
      (('get-age) age)
      (('set-name new-name)
       (<span style="color: #005e8b; font-weight: bold;">set!</span> name new-name))
      (('set-age new-age)
       (<span style="color: #005e8b; font-weight: bold;">set!</span> age new-age))
      (('say-hello)
       (format #t <span style="color: #a0132f;">"my name is ~a and I am ~a years old\n"</span>
               name age)))))


(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">me</span> (make-person <span style="color: #a0132f;">"Sam"</span> 12))

(me 'say-hello)
(me 'set-name <span style="color: #a0132f;">"John"</span>)
(me 'say-hello)
</code></pre>
</div>

<p>
Output: 
</p>

<pre class="example">
my name is Sam and I am 12 years old
my name is John and I am 12 years old
</pre>
</div>
</div>
<div id="outline-container-org11747af" class="outline-2">
<h2 id="org11747af"><span class="section-number-2">4.</span> Scheme hygienic macros</h2>
<div class="outline-text-2" id="text-4">
<p>
Another thing scheme pioneered was the use of hygienic macros for
metaprogramming. Hygienic macros prevent variable references from being shadowed
by binding created during macro expansion.
</p>

<div class="org-src-container">
<pre class="src src-scheme"><code>
(<span style="color: #005e8b; font-weight: bold;">define-syntax-rule</span> (<span style="color: #8f0075;">bind-x</span> body)
  (<span style="color: #005e8b; font-weight: bold;">let</span> ((x 42))
    body))

(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">x</span> 0)

(bind-x (+ x 1))
</code></pre>
</div>

<pre class="example">
1
</pre>

<p>
Here, if there were no hygiene, this is what the last part would expand to:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><code>(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">x</span> 0)

(bind-x (+ x 1))
</code></pre>
</div>

<div class="org-src-container">
<pre class="src src-scheme"><code>(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">x</span> 0)

(<span style="color: #005e8b; font-weight: bold;">let</span> ((x 42))
  (+ x 1))
</code></pre>
</div>
</div>
</div>
<div id="outline-container-org564c9d8" class="outline-2">
<h2 id="org564c9d8"><span class="section-number-2">5.</span> Syntax parameters</h2>
<div class="outline-text-2" id="text-5">
<p>
Syntactic parameters act a bit like normal parameters, but exist during macro
expansion. Whereas <code class="src src-scheme">parameterize</code> changes the value of a pre-existing
parameter for a limited time, <code class="src src-scheme">syntax-parameterize</code> changes the
definition of a pre-existing macro for a limited time.
</p>


<div class="org-src-container">
<pre class="src src-scheme"><code>(<span style="color: #005e8b; font-weight: bold;">define-syntax-parameter</span> return
  (<span style="color: #005e8b; font-weight: bold;">lambda</span> (s)
    (syntax-violation 'return <span style="color: #a0132f;">"return used outside `with-return`"</span> s)))

(return 123)
</code></pre>
</div>

<pre class="example">
ice-9/boot-9.scm:1685:16: In procedure raise-exception:
Syntax error:
unknown file:12:0: return: return used outside `with-return` in form (return 123)

Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
scheme@(guile-user) [1]&gt; 
</pre>

<div class="org-src-container">
<pre class="src src-scheme"><code>(<span style="color: #005e8b; font-weight: bold;">define-syntax-parameter</span> return
  (<span style="color: #005e8b; font-weight: bold;">lambda</span> (s)
    (syntax-violation 'return <span style="color: #a0132f;">"return used outside `with-return`"</span> s)))

(<span style="color: #005e8b; font-weight: bold;">define-syntax-rule</span> (<span style="color: #8f0075;">with-return</span> body body* ...)
  (<span style="color: #005e8b; font-weight: bold;">call/cc</span> (<span style="color: #005e8b; font-weight: bold;">lambda</span> (retfunc)
             (<span style="color: #005e8b; font-weight: bold;">syntax-parameterize</span>
                 ((return
                   (<span style="color: #005e8b; font-weight: bold;">lambda</span> (s) (<span style="color: #005e8b; font-weight: bold;">syntax-case</span> s () ((_ x) #'(retfunc x))))))
               body
               body* ...))))

(<span style="color: #005e8b; font-weight: bold;">define</span> <span style="color: #8f0075;">val</span>
  (with-return
   123
   (return 456)
   789))

(format #t <span style="color: #a0132f;">"val: ~a\n"</span> val)
</code></pre>
</div>

<pre class="example">
val: 456
</pre>

<p>
Guile scheme's syntax parameters let you create macros that modify the behaviour
of other macros at expansion time and it turns out that you can actually use
this same concept to have the macro expansion check the <code>await</code> keyword I defined
in <a href="async-await-syntax.html#ID-bc6ba032-8b50-4403-95db-abb7da96ae83">an old post</a> lives within an <code>async</code> block instead of throwing an error at
runtime.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2024-07-21 Sun 00:00</p>
<p class="author">Author: Justin Veilleux</p>
<p class="date">Created: 2025-09-25 Thu 18:11</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
